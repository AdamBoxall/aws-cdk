"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jsonschema = require("jsonschema");
// tslint:disable-next-line:no-var-requires
exports.schema = require('../schema/manifest.schema.json');
/**
 * Validate that ``obj`` is a valid Cloud Assembly manifest document, both syntactically and semantically. The semantic
 * validation ensures all Drop references are valid (they point to an existing Drop in the same manifest document), and
 * that there are no cycles in the dependency graph described by the manifest.
 *
 * @param obj the object to be validated.
 *
 * @returns ``obj``
 * @throws Error if ``obj`` is not a Cloud Assembly manifest document or if it is semantically invalid.
 */
function validateManifest(obj) {
    const validator = new jsonschema.Validator();
    const result = validator.validate(obj, exports.schema);
    if (result.valid) {
        return validateSemantics(obj);
    }
    throw new Error(`Invalid Cloud Assembly manifest: ${result}`);
}
exports.validateManifest = validateManifest;
function validateSemantics(manifest) {
    const dependencyGraph = {};
    for (const logicalId of Object.keys(manifest.drops)) {
        assertValidLogicalId(logicalId);
        const drop = manifest.drops[logicalId];
        const references = dependencyGraph[logicalId] = listReferences(drop, logicalId);
        for (const ref of references) {
            if (!(ref.logicalId in manifest.drops)) {
                throw new Error(`${logicalId} depends on undefined drop through ${ref.context}.`);
            }
        }
    }
    assertNoCycles();
    return manifest;
    function assertNoCycles() {
        for (const logicalId of Object.keys(dependencyGraph)) {
            for (const reference of dependencyGraph[logicalId]) {
                reference.subreferences = dependencyGraph[reference.logicalId];
            }
        }
        const cycles = Object.keys(dependencyGraph)
            .map(shortestCycle)
            .filter(cycle => cycle.length > 0)
            .sort((l, r) => l.length - r.length);
        if (cycles.length > 0) {
            const cyclesDecription = cycles.map(cycle => `- ${cycle.join(' => ')}`);
            throw new Error(`Found dependency cycles:\n${cyclesDecription.join('\n')}`);
        }
        function shortestCycle(fromId) {
            const toProcess = dependencyGraph[fromId].map(ref => ({ ref, path: [fromId] }));
            const visited = new Set();
            while (toProcess.length > 0) {
                const candidate = toProcess.pop();
                if (candidate.ref.logicalId === fromId) {
                    return [...candidate.path, candidate.ref.context];
                }
                if (!visited.has(candidate.ref.logicalId)) {
                    toProcess.unshift(...candidate.ref.subreferences.map(ref => ({ ref, path: [...candidate.path, candidate.ref.context] })));
                    visited.add(candidate.ref.logicalId);
                }
            }
            return [];
        }
    }
}
function assertValidLogicalId(str) {
    const regex = /^[A-Za-z0-9+\/_-]{1,256}$/;
    if (!str.match(regex)) {
        throw new Error(`Invalid logical ID: ${str} (does not match ${regex})`);
    }
}
function listReferences(drop, dropId) {
    const result = new Array();
    for (const logicalId of drop.dependsOn || []) {
        result.push({ logicalId, context: `dependsOn ${logicalId}` });
    }
    result.push(...listTokens(drop, dropId));
    return result;
}
function listTokens(obj, path) {
    const result = new Array();
    if (typeof obj === 'string') {
        const tokens = obj.match(/\\*\$\{[A-Za-z0-9+\/_-]{1,256}\.[^}]+\}/g);
        for (const token of tokens || []) {
            const parts = token.match(/(\\*)(\$\{([A-Za-z0-9+\/_-]{1,256})\.[^}]+\})/);
            if (parts[1].length % 2 !== 0) {
                // This one's quoted, so skip it.
                continue;
            }
            result.push({
                logicalId: parts[3],
                context: `${path} "${parts[2]}"`
            });
        }
    }
    else if (typeof obj !== 'object' || obj == null) {
        return [];
    }
    else if (Array.isArray(obj)) {
        for (let i = 0; i < obj.length; i++) {
            result.push(...listTokens(obj[i], `${path}[${i}]`));
        }
    }
    else {
        for (const key of Object.keys(obj)) {
            result.push(...listTokens(obj[key], `${path}.${key}`));
        }
    }
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUtbWFuaWZlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ2YWxpZGF0ZS1tYW5pZmVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlDQUEwQztBQUcxQywyQ0FBMkM7QUFDOUIsUUFBQSxNQUFNLEdBQXNCLE9BQU8sQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO0FBRW5GOzs7Ozs7Ozs7R0FTRztBQUNILFNBQWdCLGdCQUFnQixDQUFDLEdBQVk7SUFDM0MsTUFBTSxTQUFTLEdBQUcsSUFBSSxVQUFVLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDN0MsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsY0FBTSxDQUFDLENBQUM7SUFDL0MsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO1FBQ2hCLE9BQU8saUJBQWlCLENBQUMsR0FBZSxDQUFDLENBQUM7S0FDM0M7SUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQ2hFLENBQUM7QUFQRCw0Q0FPQztBQUVELFNBQVMsaUJBQWlCLENBQUMsUUFBa0I7SUFDM0MsTUFBTSxlQUFlLEdBQWtDLEVBQUUsQ0FBQztJQUMxRCxLQUFLLE1BQU0sU0FBUyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ25ELG9CQUFvQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2hDLE1BQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdkMsTUFBTSxVQUFVLEdBQUcsZUFBZSxDQUFDLFNBQVMsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDaEYsS0FBSyxNQUFNLEdBQUcsSUFBSSxVQUFVLEVBQUU7WUFDNUIsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsSUFBSSxRQUFRLENBQUMsS0FBSyxD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S0FBSyxRQUFRLElBQUksR0FBRyxJQUFJLElBQUksRUFBRTtRQUNqRCxPQUFPLEVBQUUsQ0FBQztLQUNYO1NBQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQzdCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFHLENBQUMsRUFBRSxFQUFFO1lBQ3JDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUNyRDtLQUNGO1NBQU07UUFDTCxLQUFLLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDbEMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBRSxHQUFXLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ2pFO0tBQ0Y7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGpzb25zY2hlbWEgPSByZXF1aXJlKCdqc29uc2NoZW1hJyk7XG5pbXBvcnQgeyBEcm9wLCBNYW5pZmVzdCB9IGZyb20gJy4vbWFuaWZlc3QnO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdmFyLXJlcXVpcmVzXG5leHBvcnQgY29uc3Qgc2NoZW1hOiBqc29uc2NoZW1hLlNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYS9tYW5pZmVzdC5zY2hlbWEuanNvbicpO1xuXG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgYGBvYmpgYCBpcyBhIHZhbGlkIENsb3VkIEFzc2VtYmx5IG1hbmlmZXN0IGRvY3VtZW50LCBib3RoIHN5bnRhY3RpY2FsbHkgYW5kIHNlbWFudGljYWxseS4gVGhlIHNlbWFudGljXG4gKiB2YWxpZGF0aW9uIGVuc3VyZXMgYWxsIERyb3AgcmVmZXJlbmNlcyBhcmUgdmFsaWQgKHRoZXkgcG9pbnQgdG8gYW4gZXhpc3RpbmcgRHJvcCBpbiB0aGUgc2FtZSBtYW5pZmVzdCBkb2N1bWVudCksIGFuZFxuICogdGhhdCB0aGVyZSBhcmUgbm8gY3ljbGVzIGluIHRoZSBkZXBlbmRlbmN5IGdyYXBoIGRlc2NyaWJlZCBieSB0aGUgbWFuaWZlc3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgb2JqZWN0IHRvIGJlIHZhbGlkYXRlZC5cbiAqXG4gKiBAcmV0dXJucyBgYG9iamBgXG4gKiBAdGhyb3dzIEVycm9yIGlmIGBgb2JqYGAgaXMgbm90IGEgQ2xvdWQgQXNzZW1ibHkgbWFuaWZlc3QgZG9jdW1lbnQgb3IgaWYgaXQgaXMgc2VtYW50aWNhbGx5IGludmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU1hbmlmZXN0KG9iajogdW5rbm93bik6IE1hbmlmZXN0IHtcbiAgY29uc3QgdmFsaWRhdG9yID0gbmV3IGpzb25zY2hlbWEuVmFsaWRhdG9yKCk7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci52YWxpZGF0ZShvYmosIHNjaGVtYSk7XG4gIGlmIChyZXN1bHQudmFsaWQpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVTZW1hbnRpY3Mob2JqIGFzIE1hbmlmZXN0KTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQ2xvdWQgQXNzZW1ibHkgbWFuaWZlc3Q6ICR7cmVzdWx0fWApO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVNlbWFudGljcyhtYW5pZmVzdDogTWFuaWZlc3QpOiBNYW5pZmVzdCB7XG4gIGNvbnN0IGRlcGVuZGVuY3lHcmFwaDogeyBbaWQ6IHN0cmluZ106IFJlZmVyZW5jZVtdIH0gPSB7fTtcbiAgZm9yIChjb25zdCBsb2dpY2FsSWQgb2YgT2JqZWN0LmtleXMobWFuaWZlc3QuZHJvcHMpKSB7XG4gICAgYXNzZXJ0VmFsaWRMb2dpY2FsSWQobG9naWNhbElkKTtcbiAgICBjb25zdCBkcm9wID0gbWFuaWZlc3QuZHJvcHNbbG9naWNhbElkXTtcbiAgICBjb25zdCByZWZlcmVuY2VzID0gZGVwZW5kZW5jeUdyYXBoW2xvZ2ljYWxJZF0gPSBsaXN0UmVmZXJlbmNlcyhkcm9wLCBsb2dpY2FsSWQpO1xuICAgIGZvciAoY29uc3QgcmVmIG9mIHJlZmVyZW5jZXMpIHtcbiAgICAgIGlmICghKHJlZi5sb2dpY2FsSWQgaW4gbWFuaWZlc3QuZHJvcHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsb2dpY2FsSWR9IGRlcGVuZHMgb24gdW5kZWZpbmVkIGRyb3AgdGhyb3VnaCAke3JlZi5jb250ZXh0fS5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXNzZXJ0Tm9DeWNsZXMoKTtcbiAgcmV0dXJuIG1hbmlmZXN0O1xuXG4gIGZ1bmN0aW9uIGFzc2VydE5vQ3ljbGVzKCkge1xuICAgIGZvciAoY29uc3QgbG9naWNhbElkIG9mIE9iamVjdC5rZXlzKGRlcGVuZGVuY3lHcmFwaCkpIHtcbiAgICAgIGZvciAoY29uc3QgcmVmZXJlbmNlIG9mIGRlcGVuZGVuY3lHcmFwaFtsb2dpY2FsSWRdKSB7XG4gICAgICAgIHJlZmVyZW5jZS5zdWJyZWZlcmVuY2VzID0gZGVwZW5kZW5jeUdyYXBoW3JlZmVyZW5jZS5sb2dpY2FsSWRdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjeWNsZXMgPSBPYmplY3Qua2V5cyhkZXBlbmRlbmN5R3JhcGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChzaG9ydGVzdEN5Y2xlKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoY3ljbGUgPT4gY3ljbGUubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgobCwgcikgPT4gbC5sZW5ndGggLSByLmxlbmd0aCk7XG4gICAgaWYgKGN5Y2xlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjeWNsZXNEZWNyaXB0aW9uID0gY3ljbGVzLm1hcChjeWNsZSA9PiBgLSAke2N5Y2xlLmpvaW4oJyA9PiAnKX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgZGVwZW5kZW5jeSBjeWNsZXM6XFxuJHtjeWNsZXNEZWNyaXB0aW9uLmpvaW4oJ1xcbicpfWApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3J0ZXN0Q3ljbGUoZnJvbUlkOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgICBjb25zdCB0b1Byb2Nlc3MgPSBkZXBlbmRlbmN5R3JhcGhbZnJvbUlkXS5tYXAocmVmID0+ICh7IHJlZiwgcGF0aDogW2Zyb21JZF0gfSkpO1xuICAgICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgd2hpbGUgKHRvUHJvY2Vzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHRvUHJvY2Vzcy5wb3AoKSE7XG4gICAgICAgIGlmIChjYW5kaWRhdGUucmVmLmxvZ2ljYWxJZCA9PT0gZnJvbUlkKSB7XG4gICAgICAgICAgcmV0dXJuIFsuLi5jYW5kaWRhdGUucGF0aCwgY2FuZGlkYXRlLnJlZi5jb250ZXh0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGNhbmRpZGF0ZS5yZWYubG9naWNhbElkKSkge1xuICAgICAgICAgIHRvUHJvY2Vzcy51bnNoaWZ0KC4uLmNhbmRpZGF0ZS5yZWYuc3VicmVmZXJlbmNlcyEubWFwKHJlZiA9PiAoeyByZWYsIHBhdGg6IFsuLi5jYW5kaWRhdGUucGF0aCwgY2FuZGlkYXRlLnJlZi5jb250ZXh0XSB9KSkpO1xuICAgICAgICAgIHZpc2l0ZWQuYWRkKGNhbmRpZGF0ZS5yZWYubG9naWNhbElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZExvZ2ljYWxJZChzdHI6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCByZWdleCA9IC9eW0EtWmEtejAtOStcXC9fLV17MSwyNTZ9JC87XG4gIGlmICghc3RyLm1hdGNoKHJlZ2V4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsb2dpY2FsIElEOiAke3N0cn0gKGRvZXMgbm90IG1hdGNoICR7cmVnZXh9KWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpc3RSZWZlcmVuY2VzKGRyb3A6IERyb3AsIGRyb3BJZDogc3RyaW5nKTogUmVmZXJlbmNlW10ge1xuICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8UmVmZXJlbmNlPigpO1xuICBmb3IgKGNvbnN0IGxvZ2ljYWxJZCBvZiBkcm9wLmRlcGVuZHNPbiB8fCBbXSkge1xuICAgIHJlc3VsdC5wdXNoKHsgbG9naWNhbElkLCBjb250ZXh0OiBgZGVwZW5kc09uICR7bG9naWNhbElkfWAgfSk7XG4gIH1cbiAgcmVzdWx0LnB1c2goLi4ubGlzdFRva2Vucyhkcm9wLCBkcm9wSWQpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbGlzdFRva2VucyhvYmo6IHVua25vd24sIHBhdGg6IHN0cmluZyk6IFJlZmVyZW5jZVtdIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PFJlZmVyZW5jZT4oKTtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgdG9rZW5zID0gb2JqLm1hdGNoKC9cXFxcKlxcJFxce1tBLVphLXowLTkrXFwvXy1dezEsMjU2fVxcLltefV0rXFx9L2cpO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zIHx8IFtdKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHRva2VuLm1hdGNoKC8oXFxcXCopKFxcJFxceyhbQS1aYS16MC05K1xcL18tXXsxLDI1Nn0pXFwuW159XStcXH0pLykhO1xuICAgICAgaWYgKHBhcnRzWzFdLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgLy8gVGhpcyBvbmUncyBxdW90ZWQsIHNvIHNraXAgaXQuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBsb2dpY2FsSWQ6IHBhcnRzWzNdLFxuICAgICAgICBjb250ZXh0OiBgJHtwYXRofSBcIiR7cGFydHNbMl19XCJgXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgZm9yIChsZXQgaSA9IDAgOyBpIDwgb2JqLmxlbmd0aCA7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goLi4ubGlzdFRva2VucyhvYmpbaV0sIGAke3BhdGh9WyR7aX1dYCkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5saXN0VG9rZW5zKChvYmogYXMgYW55KVtrZXldLCBgJHtwYXRofS4ke2tleX1gKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmludGVyZmFjZSBSZWZlcmVuY2Uge1xuICBsb2dpY2FsSWQ6IHN0cmluZztcbiAgY29udGV4dDogc3RyaW5nO1xuICBzdWJyZWZlcmVuY2VzPzogUmVmZXJlbmNlW107XG59XG4iXX0=